{"version":3,"file":"index.js.map","sources":["src/notate/index.js","src/isObject/index.js","src/flavours/index.js","src/index.js"],"sourcesContent":["/**\n * Resolve dot notation strings\n *\n * @param  {Object} context Object to start notation search (defaults to global scope)\n * @param  {String} [string=''] Dot notation representation\n * @return {Any} Whatever it finds / undefined\n *\n * @example\n * const obj = {\n *   top_level: {\n *     nested: {\n *       value: 'My Value'\n *     }\n *   }\n * };\n *\n * notate(obj, 'top_level.nested.value');\n * // 'My Value'\n *\n * notate(obj, 'top_level.missing.value');\n * // undefined\n */\nexport function notate (source, string = '') {\n  if (typeof string !== 'string') {\n    throw new TypeError(`Expected notation query to be a string, instead got ${typeof string} (${string})`)\n  }\n  return string\n    .split('.')\n    .reduce(\n      (previous, current) => typeof previous === 'object' && previous\n        ? previous[current]\n        : previous,\n      source\n    )\n}\n","/**\n * Is this a basic object?\n * @param  {any} obj\n * @return {boolean}\n */\nexport const isObject = obj => `${obj}` === '[object Object]'\n","/**\n * @property {RegExp} dollar 'Hello, ${name}'\n * @property {RegExp} double 'Hello, {{name}}'\n * @property {RegExp} single 'Hello, {name}'\n * @property {RegExp} hash 'Hello, #{name}'\n * @property {RegExp} percent 'Hello, %{name}'\n */\nexport const flavours = {\n  dollar: /\\${([^{}]*)}/gm,\n  double: /{{([^{}]*)}}/gm,\n  single: /{([^{}]*)}/gm,\n  hash: /#{([^{}]*)}/gm,\n  percent: /%{([^{}]*)}/gm\n}\n","import { notate } from './notate/index.js'\nimport { isObject } from './isObject/index.js'\nimport { flavours } from './flavours/index.js'\n\n/**\n * Valid types of results for the interpolated string\n * @private\n * @type {Array}\n * @member {String|Number}\n */\nconst VALID_RESULT_TYPES = Object.seal(['string', 'number'])\n\n/**\n  * Create new paraphrase method instance\n  * @param  {...RegExp[]} replacers\n  * @param  {Boolean}     [options.resolve=true] Should resolve dot notation within template\n  * @param  {Boolean}     [options.clean=false]  Should remove unmatched template instances\n  * @returns {Function} phraser function instance\n  *\n  * @example const phraser = paraphrase(/\\${([^{}]*)}/gm);\n  *\n  * phraser('Hello, ${name}', {name: 'Martin'})\n  */\n\nexport function paraphrase (...replacers) {\n  const options = {\n    recursive: true,\n    resolve: true,\n    clean: false\n  }\n  if (replacers.length && isObject(replacers[replacers.length - 1])) {\n    Object.assign(options, replacers.pop())\n  }\n\n  Object.freeze(replacers)\n\n  /**\n    * phraser description\n    * @param  {String}                 string       Template\n    * @param  {Object|(String|number)} data         Data for filling\n    * @param  {...(String|number)}     replacements Replacement for filling\n    * @return {String}                              Result\n    */\n  function phraser (string = '', data, ...replacements) {\n    if (typeof string !== 'string') {\n      throw new TypeError(`paraphrase expects first argument to be a string, got a ${typeof string} (${string})`)\n    }\n\n    if (!data) {\n      return string\n    }\n\n    if (VALID_RESULT_TYPES.includes(typeof data)) {\n      data = [data, ...replacements]\n    }\n\n    /**\n      * Replace method build with internal reference to the passed in data structure\n      * @param  {String} haystack The full string match\n      * @param  {String} needle   The content to identify as data member\n      * @return {String}         Found value\n      */\n    function replace (haystack, needle) {\n      const replacement = options.resolve ? notate(data, needle.trim()) : data[needle.trim()]\n\n      return VALID_RESULT_TYPES.includes(typeof replacement) ? replacement : options.clean ? '' : haystack\n    }\n\n    const result = replacers.reduce((string, replacer) => string.replace(replacer, replace), string)\n\n    return !options.recursive || string === result\n      ? result\n      : phraser(result, data, ...replacements)\n  }\n\n  Object.defineProperty(\n    phraser,\n    'patterns',\n    {\n      get: () => replacers\n    }\n  )\n\n  return phraser\n}\n\nexport const dollar = paraphrase(flavours.dollar)\nexport const double = paraphrase(flavours.double)\nexport const single = paraphrase(flavours.single)\nexport const percent = paraphrase(flavours.percent)\nexport const hash = paraphrase(flavours.hash)\nexport const loose = paraphrase(\n  flavours.dollar,\n  flavours.double,\n  flavours.percent,\n  flavours.hash,\n  flavours.single\n)\n"],"names":["notate","source","string","TypeError","split","reduce","previous","current","isObject","obj","flavours","dollar","double","single","hash","percent","VALID_RESULT_TYPES","Object","seal","paraphrase","replacers","options","recursive","resolve","clean","length","assign","pop","freeze","phraser","data","replacements","includes","replace","haystack","needle","replacement","trim","result","replacer","defineProperty","get","loose"],"mappings":"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"}