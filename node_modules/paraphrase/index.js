Object.defineProperty(exports, '__esModule', { value: true });

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/**
 * Resolve dot notation strings
 *
 * @param  {Object} context Object to start notation search (defaults to global scope)
 * @param  {String} [string=''] Dot notation representation
 * @return {Any} Whatever it finds / undefined
 *
 * @example
 * const obj = {
 *   top_level: {
 *     nested: {
 *       value: 'My Value'
 *     }
 *   }
 * };
 *
 * notate(obj, 'top_level.nested.value');
 * // 'My Value'
 *
 * notate(obj, 'top_level.missing.value');
 * // undefined
 */
function notate(source) {
  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (typeof string !== 'string') {
    throw new TypeError("Expected notation query to be a string, instead got ".concat(_typeof(string), " (").concat(string, ")"));
  }

  return string.split('.').reduce(function (previous, current) {
    return _typeof(previous) === 'object' && previous ? previous[current] : previous;
  }, source);
}

/**
 * Is this a basic object?
 * @param  {any} obj
 * @return {boolean}
 */
var isObject = function isObject(obj) {
  return "".concat(obj) === '[object Object]';
};

/**
 * @property {RegExp} dollar 'Hello, ${name}'
 * @property {RegExp} double 'Hello, {{name}}'
 * @property {RegExp} single 'Hello, {name}'
 * @property {RegExp} hash 'Hello, #{name}'
 * @property {RegExp} percent 'Hello, %{name}'
 */
var flavours = {
  dollar: /\${([^{}]*)}/gm,
  double: /{{([^{}]*)}}/gm,
  single: /{([^{}]*)}/gm,
  hash: /#{([^{}]*)}/gm,
  percent: /%{([^{}]*)}/gm
};

/**
 * Valid types of results for the interpolated string
 * @private
 * @type {Array}
 * @member {String|Number}
 */

var VALID_RESULT_TYPES = Object.seal(['string', 'number']);
/**
  * Create new paraphrase method instance
  * @param  {...RegExp[]} replacers
  * @param  {Boolean}     [options.resolve=true] Should resolve dot notation within template
  * @param  {Boolean}     [options.clean=false]  Should remove unmatched template instances
  * @returns {Function} phraser function instance
  *
  * @example const phraser = paraphrase(/\${([^{}]*)}/gm);
  *
  * phraser('Hello, ${name}', {name: 'Martin'})
  */

function paraphrase() {
  for (var _len = arguments.length, replacers = new Array(_len), _key = 0; _key < _len; _key++) {
    replacers[_key] = arguments[_key];
  }

  var options = {
    recursive: true,
    resolve: true,
    clean: false
  };

  if (replacers.length && isObject(replacers[replacers.length - 1])) {
    Object.assign(options, replacers.pop());
  }

  Object.freeze(replacers);
  /**
    * phraser description
    * @param  {String}                 string       Template
    * @param  {Object|(String|number)} data         Data for filling
    * @param  {...(String|number)}     replacements Replacement for filling
    * @return {String}                              Result
    */

  function phraser() {
    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var data = arguments.length > 1 ? arguments[1] : undefined;

    if (typeof string !== 'string') {
      throw new TypeError("paraphrase expects first argument to be a string, got a ".concat(_typeof(string), " (").concat(string, ")"));
    }

    if (!data) {
      return string;
    }

    for (var _len2 = arguments.length, replacements = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      replacements[_key2 - 2] = arguments[_key2];
    }

    if (VALID_RESULT_TYPES.includes(_typeof(data))) {
      data = [data].concat(replacements);
    }
    /**
      * Replace method build with internal reference to the passed in data structure
      * @param  {String} haystack The full string match
      * @param  {String} needle   The content to identify as data member
      * @return {String}         Found value
      */


    function replace(haystack, needle) {
      var replacement = options.resolve ? notate(data, needle.trim()) : data[needle.trim()];
      return VALID_RESULT_TYPES.includes(_typeof(replacement)) ? replacement : options.clean ? '' : haystack;
    }

    var result = replacers.reduce(function (string, replacer) {
      return string.replace(replacer, replace);
    }, string);
    return !options.recursive || string === result ? result : phraser.apply(void 0, [result, data].concat(replacements));
  }

  Object.defineProperty(phraser, 'patterns', {
    get: function get() {
      return replacers;
    }
  });
  return phraser;
}
var dollar = paraphrase(flavours.dollar);
var double = paraphrase(flavours.double);
var single = paraphrase(flavours.single);
var percent = paraphrase(flavours.percent);
var hash = paraphrase(flavours.hash);
var loose = paraphrase(flavours.dollar, flavours.double, flavours.percent, flavours.hash, flavours.single);

exports.dollar = dollar;
exports.double = double;
exports.hash = hash;
exports.loose = loose;
exports.paraphrase = paraphrase;
exports.percent = percent;
exports.single = single;
//# sourceMappingURL=index.js.map
